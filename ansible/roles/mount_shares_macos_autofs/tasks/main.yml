# Copyright (c) 2025 MikeT LLC. All rights reserved.

---
# =============================================================================
# AUTOFS-BASED macOS MOUNTS
# =============================================================================
#
# This role configures autofs for on-demand SMB mounts on macOS. Unlike manual
# mount_smbfs mounts, autofs:
#   - Only mounts when accessed
#   - Automatically unmounts after idle timeout
#   - Won't create stale mounts that break Time Machine
#   - Handles network interruptions gracefully
#
# USE THIS ROLE FOR:
#   - macOS workstations that need reliable SMB mounts
#   - Any macOS client that should handle network hiccups gracefully
#
# =============================================================================

# Phase 1: Clean up old manual mounts
- name: Clean up old manual mounts
  include_tasks: cleanup_manual_mounts.yml

# Phase 2: Check prerequisites
- name: Check for SMB secrets env file
  stat:
    path: "{{ smb_env_file }}"
  register: smb_env_stat
  changed_when: false

- name: Fail when SMB secrets env file is missing
  fail:
    msg: "{{ smb_env_file }} missing. Run ansible/playbooks/secrets-sync.yml to pull mount credentials from Azure Key Vault."
  when: not smb_env_stat.stat.exists

- name: Harden SMB secrets env file permissions
  file:
    path: "{{ smb_env_file }}"
    mode: '0600'
  when: smb_env_stat.stat.exists

# Phase 3: Read SMB password for URL encoding
# NOTE: Password source is Azure Key Vault secret 'motoko-smb-password'
# Synced to ~/.mkt/mounts.env via ansible/playbooks/secrets-sync.yml
# This follows PHC secrets architecture: AKV → ephemeral .env cache → role consumption
- name: Read SMB password from env file (synced from AKV)
  shell: |
    set -o allexport
    source {{ smb_env_file }}
    set +o allexport
    python3 -c "import urllib.parse; print(urllib.parse.quote('$SMB_PASSWORD', safe=''))"
  register: smb_password_encoded
  changed_when: false
  no_log: true
  become: false

# Phase 4: Configure autofs
# Note: macOS SIP makes /mnt read-only, so we use /Volumes/motoko instead
- name: Ensure base mount point exists
  file:
    path: "{{ autofs_mount_base }}"
    state: directory
    mode: '0755'
  become: true

- name: Check if autofs master entry exists
  lineinfile:
    path: /etc/auto_master
    regexp: "^{{ autofs_mount_base | regex_escape }}"
    line: "{{ autofs_mount_base }} /etc/auto.motoko --timeout={{ autofs_timeout }}"
    state: present
  become: true
  register: autofs_master_changed
  notify: Reload autofs

- name: Create autofs map for motoko shares
  copy:
    content: |
      # Autofs map for motoko SMB shares
      # Auto-generated by Ansible - do not edit manually
      #
      # Shares are mounted on-demand when accessed, unmounted after {{ autofs_timeout }}s idle
      # This avoids stale mounts that break Time Machine and other services
      #
      # NOTE: macOS autofs does not support credentials files like Linux.
      # Password is URL-encoded and embedded here (restricted to root:wheel, mode 0600).
      # Source: Azure Key Vault secret 'motoko-smb-password' via secrets-sync.yml → ~/.mkt/mounts.env
      #
      {% for share in smb_shares %}
      {{ share.name }} -fstype=smbfs,soft,noowners,nosuid,rw ://{{ smb_username }}:{{ smb_password_encoded.stdout }}@{{ smb_server }}{{ share.path }}
      {% endfor %}
    dest: /etc/auto.motoko
    owner: root
    group: wheel
    mode: '0600'  # Restrictive permissions (was 0644) - contains URL-encoded password
  become: true
  register: autofs_map_changed
  no_log: true
  notify: Reload autofs

# Phase 5: Create user symlinks
- name: Create user symlinks to autofs mount points
  file:
    src: "{{ autofs_mount_base }}/{{ item.name }}"
    dest: "{{ item.link | replace('~', ansible_env.HOME) }}"
    state: link
    force: yes
  loop: "{{ user_symlinks }}"
  become: false

# Phase 5b: Remove ~/time symlink if it exists (Time Machine manages its own mount)
- name: Remove ~/time symlink (Time Machine manages time share directly)
  file:
    path: "{{ ansible_env.HOME }}/time"
    state: absent
  become: false
  failed_when: false

# Phase 5c: Unmount any existing autofs time mount (Time Machine needs direct control)
- name: Unmount existing autofs time mount if present
  command: umount {{ autofs_mount_base }}/time
  become: true
  register: unmount_time
  failed_when: false
  changed_when: unmount_time.rc == 0

# Phase 6: Ensure automountd is running
- name: Check if automountd is running
  command: launchctl list | grep -q com.apple.automountd || echo "not_running"
  register: automountd_status
  changed_when: false
  failed_when: false

- name: Start automountd if not running
  command: launchctl load -w /System/Library/LaunchDaemons/com.apple.automountd.plist
  become: true
  when: "'not_running' in automountd_status.stdout"

- name: Reload autofs configuration
  command: automount -vc
  become: true
  changed_when: true

# Phase 7: Display configuration summary
- name: Display autofs configuration summary
  debug:
    msg: |
      ═══════════════════════════════════════════════════════════════
      AUTOFS CONFIGURED FOR SMB MOUNTS (macOS)
      ═══════════════════════════════════════════════════════════════
      
      Mount base: {{ autofs_mount_base }}
      Idle timeout: {{ autofs_timeout }} seconds
      
      Shares configured:
      {% for share in smb_shares %}
        - {{ autofs_mount_base }}/{{ share.name }} → //{{ smb_username }}@{{ smb_server }}{{ share.path }}
      {% endfor %}
      
      User symlinks:
      {% for link in user_symlinks %}
        - {{ link.link }} → {{ autofs_mount_base }}/{{ link.name }}
      {% endfor %}
      
      Benefits over manual mount_smbfs:
        ✓ Mounts only when accessed (on-demand)
        ✓ Unmounts automatically after idle timeout
        ✓ No stale mounts that break Time Machine
        ✓ Handles network interruptions gracefully
        ✓ No need for periodic mount checking scripts
      
      ═══════════════════════════════════════════════════════════════

