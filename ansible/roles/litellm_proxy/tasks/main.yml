# Copyright (c) 2025 MikeT LLC. All rights reserved.

---
# LiteLLM Proxy Deployment Tasks
# Idempotent tasks to deploy and manage LiteLLM proxy
# Supports both Docker (Debian) and Podman (Fedora)

- name: Display LiteLLM deployment info
  ansible.builtin.debug:
    msg:
      - "═══════════════════════════════════════════════════════════"
      - "LiteLLM PROXY DEPLOYMENT"
      - "═══════════════════════════════════════════════════════════"
      - ""
      - "Container Runtime: {{ litellm_container_runtime }}"
      - "Work Directory:    {{ litellm_workdir }}"
      - "Bind Address:      {{ litellm_bind_host }}:{{ litellm_port }}"
      - "Backend Type:      {{ litellm_backend_type | default('vllm') }}"
      - ""
      - "═══════════════════════════════════════════════════════════"
  tags: [litellm]

# ========================================
# Directory Setup
# ========================================
- name: Ensure LiteLLM workdir exists
  ansible.builtin.file:
    path: "{{ litellm_workdir }}"
    state: directory
    owner: root
    group: root
    mode: "0755"
  tags: [litellm, setup]

# ========================================
# Configuration
# ========================================
- name: Render LiteLLM config
  ansible.builtin.template:
    src: "litellm.config.yaml.j2"
    dest: "{{ litellm_config_path }}"
    owner: root
    group: root
    mode: "0644"
  notify: restart litellm
  tags: [litellm, config]

- name: Verify LiteLLM env file is present (generated by secrets_sync)
  ansible.builtin.stat:
    path: "{{ litellm_env_path }}"
  register: litellm_env_stat
  changed_when: false
  tags: [litellm, secrets]

- name: Warn if LiteLLM env file is missing
  ansible.builtin.debug:
    msg: |
      ⚠️  {{ litellm_env_path }} is missing.

      To generate secrets, run:
        ansible-playbook playbooks/secrets-sync.yml --limit {{ inventory_hostname }}

      Or create a minimal .env file with:
        LITELLM_MASTER_KEY=your-secret-token
  when:
    - not litellm_env_stat.stat.exists
    - litellm_require_secrets | bool
  tags: [litellm, secrets]

- name: Create minimal env file if missing (no auth - tailnet provides security)
  ansible.builtin.copy:
    dest: "{{ litellm_env_path }}"
    content: |
      # LiteLLM environment
      # No LITELLM_MASTER_KEY - tailnet provides access control
      # To enable auth, add: LITELLM_MASTER_KEY=your-secret-token
    mode: "0600"
  when:
    - not litellm_env_stat.stat.exists
    - not (litellm_require_secrets | bool)
  tags: [litellm, secrets]

- name: Render compose file
  ansible.builtin.template:
    src: "docker-compose.yml.j2"
    dest: "{{ litellm_compose_path }}"
    owner: root
    group: root
    mode: "0644"
  notify: restart litellm
  tags: [litellm, config]

# ========================================
# Runtime Setup - Fedora/Podman
# ========================================
- name: Ensure Podman and podman-compose are installed (Fedora)
  ansible.builtin.dnf:
    name:
      - podman
      - podman-compose
    state: present
  when: ansible_distribution == "Fedora"
  tags: [litellm, packages]

# ========================================
# Runtime Setup - Debian/Docker
# ========================================
- name: Check if Docker is installed (Debian)
  ansible.builtin.command: which docker
  register: docker_check
  changed_when: false
  failed_when: false
  when: ansible_os_family == "Debian"
  tags: [litellm, runtime]

- name: Install Docker + Compose plugin (Debian)
  ansible.builtin.apt:
    name:
      - docker.io
      - docker-compose-plugin
    state: present
    update_cache: yes
  when:
    - ansible_os_family == "Debian"
    - docker_check.rc != 0
  tags: [litellm, packages]

- name: Ensure Docker service is running (Debian)
  ansible.builtin.systemd:
    name: docker
    state: started
    enabled: true
  when: ansible_os_family == "Debian"
  tags: [litellm, runtime]

# ========================================
# Security - File Permissions
# ========================================
- name: Ensure LiteLLM env file permissions are restrictive
  ansible.builtin.file:
    path: "{{ litellm_env_path }}"
    owner: root
    group: root
    mode: "0600"
  when: litellm_env_stat.stat.exists
  tags: [litellm, security]

# ========================================
# Firewall Configuration (firewalld)
# ========================================
- name: Open LiteLLM port in firewalld (tailnet only)
  ansible.posix.firewalld:
    port: "{{ litellm_port }}/tcp"
    zone: "{{ litellm_firewall_zone }}"
    permanent: true
    immediate: true
    state: enabled
  when:
    - litellm_firewall_enabled | default(true)
    - ansible_distribution == "Fedora"
    - litellm_bind_host != '127.0.0.1'
  tags: [litellm, firewall]

- name: Add rich rule to restrict LiteLLM to tailnet
  ansible.posix.firewalld:
    rich_rule: 'rule family="ipv4" source address="{{ litellm_firewall_source }}" port port="{{ litellm_port }}" protocol="tcp" accept'
    zone: "{{ litellm_firewall_zone }}"
    permanent: true
    immediate: true
    state: enabled
  when:
    - litellm_firewall_enabled | default(true)
    - ansible_distribution == "Fedora"
    - litellm_bind_host != '127.0.0.1'
  tags: [litellm, firewall]

# ========================================
# SELinux Configuration
# ========================================
- name: Allow container to bind to LiteLLM port (SELinux)
  community.general.seport:
    ports: "{{ litellm_port }}"
    proto: tcp
    setype: http_port_t
    state: present
  when:
    - ansible_distribution == "Fedora"
    - ansible_selinux.status == "enabled"
  ignore_errors: true  # May already be allowed
  tags: [litellm, selinux]

# ========================================
# Deploy Container
# ========================================
- name: Pull LiteLLM image
  ansible.builtin.command: "{{ litellm_container_runtime }} pull {{ litellm_image }}"
  register: pull_result
  changed_when: "'Downloaded' in pull_result.stdout or 'Pulling' in pull_result.stdout"
  tags: [litellm, deploy]

- name: Start LiteLLM via compose
  ansible.builtin.command: "{{ litellm_container_runtime }}-compose -f {{ litellm_compose_path }} up -d"
  args:
    chdir: "{{ litellm_workdir }}"
  register: compose_result
  changed_when: "'Creating' in compose_result.stdout or 'Starting' in compose_result.stdout or compose_result.rc == 0"
  tags: [litellm, deploy]

# ========================================
# Systemd Integration
# ========================================
- name: Create systemd unit
  ansible.builtin.template:
    src: "litellm.service.j2"
    dest: "/etc/systemd/system/{{ litellm_service_name }}.service"
    owner: root
    group: root
    mode: "0644"
  notify: reload systemd
  tags: [litellm, systemd]

- name: Enable LiteLLM service
  ansible.builtin.systemd:
    name: "{{ litellm_service_name }}"
    enabled: true
    daemon_reload: true
  tags: [litellm, systemd]

# ========================================
# Verification
# ========================================
- name: Wait for LiteLLM service to be ready
  ansible.builtin.wait_for:
    port: "{{ litellm_port }}"
    host: "127.0.0.1"
    delay: 5
    timeout: 60
  tags: [litellm, verify]

- name: Verify LiteLLM health endpoint
  ansible.builtin.uri:
    url: "http://127.0.0.1:{{ litellm_port }}/health"
    method: GET
    return_content: yes
  register: health_check
  retries: 3
  delay: 5
  until: health_check.status == 200
  tags: [litellm, verify]

- name: Verify LiteLLM models endpoint
  ansible.builtin.uri:
    url: "http://127.0.0.1:{{ litellm_port }}/v1/models"
    method: GET
    return_content: yes
  register: models_response
  tags: [litellm, verify]

- name: Display available models
  ansible.builtin.debug:
    msg: "Available models: {{ models_response.json.data | map(attribute='id') | list }}"
  when: models_response.json is defined
  tags: [litellm, verify]

# ========================================
# Backend Health Verification
# ========================================
- name: Check vLLM backend health
  ansible.builtin.uri:
    url: "http://{{ item.host }}:{{ item.port }}/health"
    method: GET
    timeout: 10
  loop: "{{ vllm_backends }}"
  loop_control:
    label: "{{ item.name }} ({{ item.host }}:{{ item.port }})"
  register: backend_health
  ignore_errors: true
  tags: [litellm, verify, backends]

- name: Report backend health status
  ansible.builtin.debug:
    msg: |
      Backend Health Status:
      {% for result in backend_health.results %}
      - {{ result.item.name }}: {{ 'HEALTHY' if result.status == 200 else 'UNHEALTHY (' ~ (result.msg | default('unknown error')) ~ ')' }}
      {% endfor %}
  tags: [litellm, verify, backends]

- name: Display LiteLLM deployment summary
  ansible.builtin.debug:
    msg:
      - "═══════════════════════════════════════════════════════════"
      - "LiteLLM DEPLOYMENT COMPLETE"
      - "═══════════════════════════════════════════════════════════"
      - ""
      - "Endpoint:    http://{{ inventory_hostname }}.pangolin-vega.ts.net:{{ litellm_port }}/v1"
      - "Models API:  http://{{ inventory_hostname }}.pangolin-vega.ts.net:{{ litellm_port }}/v1/models"
      - "Health:      http://{{ inventory_hostname }}.pangolin-vega.ts.net:{{ litellm_port }}/health"
      - ""
      - "Default Model: {{ litellm_default_model }}"
      - ""
      - "Test with:"
      - "  curl http://{{ inventory_hostname }}:{{ litellm_port }}/v1/models"
      - ""
      - "Management:"
      - "  {{ litellm_container_runtime }}-compose -f {{ litellm_compose_path }} logs -f"
      - "  systemctl status {{ litellm_service_name }}"
      - ""
      - "═══════════════════════════════════════════════════════════"
  tags: [litellm]
