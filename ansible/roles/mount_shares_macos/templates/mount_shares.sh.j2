#!/bin/bash
# Auto-generated by Ansible
# Mounts Samba shares from PHC storage hosts to ~/.mkt/* using per-user credentials

# Log function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a ~/.scripts/mount_shares.log
}

log "Starting mount script for user: $USER..."

wait_for_server() {
    local server="$1"
    local count=0
    while ! ping -c 1 "$server" &> /dev/null; do
        sleep 5
        ((count++))
        if [ $count -gt 12 ]; then
            log "Timeout waiting for network connectivity to $server."
            return 1
        fi
    done
    return 0
}

SECRETS_FILE="{{ smb_env_file | expanduser }}"

if [ -f "$SECRETS_FILE" ]; then
    set -o allexport
    source "$SECRETS_FILE"
    set +o allexport
fi

if [ -z "$SMB_PASSWORD" ]; then
    log "ERROR: SMB_PASSWORD is not present. Run ansible/playbooks/secrets-sync.yml to fetch credentials from Azure Key Vault."
    exit 1
fi

# URL-encode the password for mount_smbfs
# This handles special characters like @, :, /, etc.
SMB_PASSWORD_ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$SMB_PASSWORD', safe=''))")

{% for share in smb_shares %}
# Mount {{ share.name }} to {{ share.mount_point }}
# Each user mounts with their own credentials (per-user SMB session)
MOUNT_POINT="{{ share.mount_point | replace('~', '$HOME') }}"
SERVER="{{ share.server | default(smb_server) }}"

# Ensure mount point exists
if [ ! -d "${MOUNT_POINT}" ]; then
    log "ERROR: Mount point ${MOUNT_POINT} does not exist. Run Ansible to create it."
    continue
fi

if ! wait_for_server "$SERVER"; then
    log "Skipping {{ share.name }} - server $SERVER unreachable."
    continue
fi

# Check if mount exists and is actually working
MOUNT_EXISTS=$(mount | grep -q "on ${MOUNT_POINT} " && echo "yes" || echo "no")
MOUNT_WORKING="no"

if [ "$MOUNT_EXISTS" == "yes" ]; then
    # Test if mount is actually accessible (not stale)
    if ls "${MOUNT_POINT}" >/dev/null 2>&1; then
        MOUNT_WORKING="yes"
        log "{{ share.name }} is mounted and accessible at ${MOUNT_POINT}."
    else
        log "WARNING: {{ share.name }} appears mounted but is not accessible (stale mount). Unmounting..."
        umount "${MOUNT_POINT}" 2>/dev/null || true
        # Wait a moment for unmount to complete
        sleep 1
    fi
fi

# Mount if not mounted or was stale
if [ "$MOUNT_WORKING" != "yes" ]; then
    log "Mounting {{ share.name }} to ${MOUNT_POINT}..."
    
    # Mount with SMB credentials
    # mount_smbfs takes the password via the URL: //user:password@server/share
    mount_smbfs "//{{ smb_username }}:${SMB_PASSWORD_ENCODED}@${SERVER}{{ share.path }}" "${MOUNT_POINT}"
    
    if [ $? -eq 0 ]; then
        # Verify mount is actually working
        sleep 1
        if ls "${MOUNT_POINT}" >/dev/null 2>&1; then
            log "Successfully mounted {{ share.name }} to ${MOUNT_POINT}."
        else
            log "WARNING: {{ share.name }} mount command succeeded but mount is not accessible. Check network connectivity."
        fi
    else
        log "Failed to mount {{ share.name }}. Check credentials and network connectivity."
    fi
fi
{% endfor %}

log "Mount script completed."

# Immediately create user symlinks after mounts are up
log "Creating user symlinks..."

{% for symlink in user_symlinks %}
# Symlink: {{ symlink.name }}
LINK_PATH="${HOME}/{{ symlink.name }}"
TARGET_PATH="{{ symlink.target | replace('~', '$HOME') }}"

if [ -L "$LINK_PATH" ] && [ ! -e "$LINK_PATH" ]; then
    rm -f "$LINK_PATH"
fi

if [ ! -e "$LINK_PATH" ]; then
    if [ -d "$TARGET_PATH" ]; then
        ln -s "$TARGET_PATH" "$LINK_PATH" && log "Created symlink: ~/{{ symlink.name }}"
    fi
elif [ -L "$LINK_PATH" ]; then
    CURRENT=$(readlink "$LINK_PATH")
    if [ "$CURRENT" != "$TARGET_PATH" ]; then
        rm -f "$LINK_PATH" && ln -s "$TARGET_PATH" "$LINK_PATH" && log "Updated symlink: ~/{{ symlink.name }}"
    fi
fi
{% endfor %}

log "Setup complete. Access your files via ~/flux, ~/space, ~/time"

# --- Device Health Reporting ---
log "Reporting device health..."

HOSTNAME=$(hostname -s)
# Username is $USER

# Define status file path
# We expect /space to be mounted at ~/.mkt/space per convention
SPACE_MOUNT="${HOME}/.mkt/space"
STATUS_DIR="${SPACE_MOUNT}/devices/${HOSTNAME}/${USER}"
STATUS_FILE="${STATUS_DIR}/_status.json"

# Check mount status
FLUX_MOUNTED=$(mount | grep -q "${HOME}/.mkt/flux" && echo "true" || echo "false")
SPACE_MOUNTED=$(mount | grep -q "${HOME}/.mkt/space" && echo "true" || echo "false")
TIME_MOUNTED=$(mount | grep -q "${HOME}/.mkt/time" && echo "true" || echo "false")

# Determine overall status
if [ "$FLUX_MOUNTED" == "true" ] && [ "$SPACE_MOUNTED" == "true" ]; then
    OVERALL_STATUS="healthy"
else
    OVERALL_STATUS="degraded"
fi

# Create JSON content
JSON_CONTENT=$(cat <<EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "device": "${HOSTNAME}",
  "user": "${USER}",
  "platform": "macOS",
  "status": "${OVERALL_STATUS}",
  "components": {
    "mounts": {
      "flux": ${FLUX_MOUNTED},
      "space": ${SPACE_MOUNTED},
      "time": ${TIME_MOUNTED}
    }
  }
}
EOF
)

if [ "$SPACE_MOUNTED" == "true" ]; then
    if [ ! -d "$STATUS_DIR" ]; then
        mkdir -p "$STATUS_DIR"
    fi
    echo "$JSON_CONTENT" > "$STATUS_FILE"
    log "Health status written to ${STATUS_FILE}"
else
    log "ERROR: Cannot write health status - /space is not mounted."
fi
