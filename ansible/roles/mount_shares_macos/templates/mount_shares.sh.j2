#!/bin/bash
# Auto-generated by Ansible
# Mounts Samba shares from Motoko to system-level /mkt/* using per-user credentials

# Log function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a ~/.scripts/mount_shares.log
}

log "Starting mount script for user: $USER..."

# Ensure Azure CLI is available
if ! command -v az &> /dev/null; then
    log "ERROR: Azure CLI (az) is not installed or not in PATH."
    exit 1
fi

# Wait for network (simple check)
count=0
while ! ping -c 1 {{ smb_server }} &> /dev/null; do
    sleep 5
    ((count++))
    if [ $count -gt 12 ]; then 
        log "Timeout waiting for network connectivity to {{ smb_server }}."
        exit 0 # Exit gracefully, maybe we are offline
    fi
done

log "Network is up. Fetching credentials from Azure Key Vault '{{ akv_vault_name }}'..."

# Fetch password from Azure Key Vault
# Note: Requires active 'az login' session or Service Principal environment variables
SMB_PASSWORD=$(az keyvault secret show --vault-name "{{ akv_vault_name }}" --name "{{ akv_secret_name }}" --query value -o tsv 2>/dev/null)

if [ -z "$SMB_PASSWORD" ]; then
    log "ERROR: Failed to retrieve secret '{{ akv_secret_name }}' from Key Vault. Check 'az login' status."
    exit 1
fi

# URL-encode the password for mount_smbfs
# This handles special characters like @, :, /, etc.
SMB_PASSWORD_ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$SMB_PASSWORD', safe=''))")

{% for share in smb_shares %}
# Mount {{ share.name }} to {{ share.mount_point }}
# Each user mounts with their own credentials (per-user SMB session)
MOUNT_POINT="{{ share.mount_point | replace('~', '$HOME') }}"

if ! mount | grep -q "on ${MOUNT_POINT} "; then
    log "Mounting {{ share.name }} to ${MOUNT_POINT}..."
    
    # Ensure mount point exists
    if [ ! -d "${MOUNT_POINT}" ]; then
        log "ERROR: Mount point ${MOUNT_POINT} does not exist. Run Ansible to create it."
        continue
    fi
    
    # Mount with SMB credentials
    # mount_smbfs takes the password via the URL: //user:password@server/share
    mount_smbfs "//{{ smb_username }}:${SMB_PASSWORD_ENCODED}@{{ smb_server }}{{ share.path }}" "${MOUNT_POINT}"
    
    if [ $? -eq 0 ]; then
        log "Successfully mounted {{ share.name }} to ${MOUNT_POINT}."
    else
        log "Failed to mount {{ share.name }}. Check credentials and network connectivity."
    fi
else
    log "{{ share.name }} is already mounted at ${MOUNT_POINT}."
fi
{% endfor %}

log "Mount script completed."

# Immediately create user symlinks after mounts are up
log "Creating user symlinks..."

{% for symlink in user_symlinks %}
# Symlink: {{ symlink.name }}
LINK_PATH="${HOME}/{{ symlink.name }}"
TARGET_PATH="{{ symlink.target | replace('~', '$HOME') }}"

if [ -L "$LINK_PATH" ] && [ ! -e "$LINK_PATH" ]; then
    rm -f "$LINK_PATH"
fi

if [ ! -e "$LINK_PATH" ]; then
    if [ -d "$TARGET_PATH" ]; then
        ln -s "$TARGET_PATH" "$LINK_PATH" && log "Created symlink: ~/{{ symlink.name }}"
    fi
elif [ -L "$LINK_PATH" ]; then
    CURRENT=$(readlink "$LINK_PATH")
    if [ "$CURRENT" != "$TARGET_PATH" ]; then
        rm -f "$LINK_PATH" && ln -s "$TARGET_PATH" "$LINK_PATH" && log "Updated symlink: ~/{{ symlink.name }}"
    fi
fi
{% endfor %}

log "Setup complete. Access your files via ~/flux, ~/space, ~/time"

# --- Device Health Reporting ---
log "Reporting device health..."

HOSTNAME=$(hostname -s)
# Username is $USER

# Define status file path
# We expect /space to be mounted at ~/.mkt/space per convention
SPACE_MOUNT="${HOME}/.mkt/space"
STATUS_DIR="${SPACE_MOUNT}/devices/${HOSTNAME}/${USER}"
STATUS_FILE="${STATUS_DIR}/_status.json"

# Check mount status
FLUX_MOUNTED=$(mount | grep -q "${HOME}/.mkt/flux" && echo "true" || echo "false")
SPACE_MOUNTED=$(mount | grep -q "${HOME}/.mkt/space" && echo "true" || echo "false")
TIME_MOUNTED=$(mount | grep -q "${HOME}/.mkt/time" && echo "true" || echo "false")

# Determine overall status
if [ "$FLUX_MOUNTED" == "true" ] && [ "$SPACE_MOUNTED" == "true" ]; then
    OVERALL_STATUS="healthy"
else
    OVERALL_STATUS="degraded"
fi

# Create JSON content
JSON_CONTENT=$(cat <<EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "device": "${HOSTNAME}",
  "user": "${USER}",
  "platform": "macOS",
  "status": "${OVERALL_STATUS}",
  "components": {
    "mounts": {
      "flux": ${FLUX_MOUNTED},
      "space": ${SPACE_MOUNTED},
      "time": ${TIME_MOUNTED}
    }
  }
}
EOF
)

if [ "$SPACE_MOUNTED" == "true" ]; then
    if [ ! -d "$STATUS_DIR" ]; then
        mkdir -p "$STATUS_DIR"
    fi
    echo "$JSON_CONTENT" > "$STATUS_FILE"
    log "Health status written to ${STATUS_FILE}"
else
    log "ERROR: Cannot write health status - /space is not mounted."
fi

