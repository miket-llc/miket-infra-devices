# Auto-generated by Ansible
# Maps network drives X:, S:, T: to motoko SMB shares

$ErrorActionPreference = "Continue"

# SMB Configuration
$server = "{{ smb_server }}"
$username = "mdt"
$password = "{{ smb_password }}"

Write-Host "Mapping network drives to $server..."

# Wait for Tailscale to be ready using Tailscale's own status command
# This is more reliable than polling - we check Tailscale's backend state directly
$maxWaitSeconds = 300
$waitIntervalSeconds = 5
$waitedSeconds = 0
$tailscaleReady = $false

Write-Host "Waiting for Tailscale to be ready..."
Write-Host "This may take up to 5 minutes after Windows boot..."

# Check if Tailscale executable exists
$tailscaleExe = "C:\Program Files\Tailscale\tailscale.exe"
if (-not (Test-Path $tailscaleExe)) {
    Write-Warning "Tailscale executable not found at $tailscaleExe. Skipping readiness check."
    $tailscaleReady = $true  # Proceed anyway
}

while ($waitedSeconds -lt $maxWaitSeconds -and -not $tailscaleReady) {
    try {
        # Use Tailscale's status command to check backend state
        # BackendState should be "Running" when connected
        $statusJson = & $tailscaleExe status --json 2>&1
        if ($LASTEXITCODE -eq 0) {
            $status = $statusJson | ConvertFrom-Json
            $backendState = $status.BackendState
            
            if ($backendState -eq "Running") {
                $tailscaleReady = $true
                Write-Host "Tailscale is ready (BackendState: $backendState) after $waitedSeconds seconds"
            } else {
                if ($waitedSeconds % 30 -eq 0) {
                    Write-Host "Tailscale backend state: $backendState (waiting for 'Running'... $waitedSeconds / $maxWaitSeconds seconds)"
                }
                Start-Sleep -Seconds $waitIntervalSeconds
                $waitedSeconds += $waitIntervalSeconds
            }
        } else {
            # Tailscale service might not be started yet
            if ($waitedSeconds % 30 -eq 0) {
                Write-Host "Tailscale status command failed (service may be starting)... ($waitedSeconds / $maxWaitSeconds seconds)"
            }
            Start-Sleep -Seconds $waitIntervalSeconds
            $waitedSeconds += $waitIntervalSeconds
        }
    } catch {
        # JSON parsing or other error - service might be starting
        if ($waitedSeconds % 30 -eq 0) {
            Write-Host "Error checking Tailscale status (service may be starting)... ($waitedSeconds / $maxWaitSeconds seconds)"
        }
        Start-Sleep -Seconds $waitIntervalSeconds
        $waitedSeconds += $waitIntervalSeconds
    }
}

if (-not $tailscaleReady) {
    Write-Warning "Tailscale did not become ready after $maxWaitSeconds seconds. Attempting drive mapping anyway..."
    Write-Warning "Drives may appear disconnected until Tailscale is ready. You can manually reconnect them later."
}

# Drive mappings
$drives = @(
{% for share in smb_shares %}
    @{
        Letter = "{{ share.drive_letter }}"
        Path = "{{ share.path }}"
        Label = "{{ share.label }}"
        Name = "{{ share.name }}"
    }{{ "," if not loop.last else "" }}
{% endfor %}
)

foreach ($drive in $drives) {
    $letter = $drive.Letter
    $sharePath = ($drive.Path -replace '^[/\\]+','') -replace '/', '\'
    $uncPath = "\\$server\$sharePath"
    
    Write-Host "Processing drive ${letter}:..."
    
    # Check if already mapped to the correct path
    $existing = Get-PSDrive -Name $letter -PSProvider FileSystem -ErrorAction SilentlyContinue
    
    if ($existing -and $existing.DisplayRoot -eq $uncPath) {
        Write-Host "  Drive ${letter}: already mapped to $uncPath"
    } else {
        # Disconnect any existing mapping (including remembered connections)
        if ($existing) {
            Write-Host "  Disconnecting existing mapping: $($existing.DisplayRoot)"
            net use ${letter}: /delete /yes 2>&1 | Out-Null
        }
        
        # Also delete any remembered connections
        net use ${letter}: /delete /yes 2>&1 | Out-Null
        
        Write-Host "  Mapping ${letter}: to $uncPath..."
        
        # Use net use with credentials and force overwrite
        $netCmd = "net use ${letter}: $uncPath /user:$username `"$password`" /persistent:yes /yes 2>&1"
        $output = Invoke-Expression $netCmd
        if ($LASTEXITCODE -eq 0) {
            Write-Host "  Successfully mapped ${letter}:"
        } else {
            Write-Host "  ERROR: Failed to map ${letter}:"
            Write-Host $output
        }
    }
}

Write-Host "Drive mapping complete."

# --- Device Health Reporting ---
Write-Host "Reporting device health..."

$hostname = $env:COMPUTERNAME
$user = $env:USERNAME
$spaceDrive = "S:"
$statusDir = "${spaceDrive}\devices\${hostname}\${user}"
$statusFile = "${statusDir}\_status.json"

# Check drive status
$fluxMounted = (Test-Path "X:\")
$spaceMounted = (Test-Path "S:\")
$timeMounted = (Test-Path "T:\")

if ($fluxMounted -and $spaceMounted) {
    $overallStatus = "healthy"
} else {
    $overallStatus = "degraded"
}

$timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")

$jsonPayload = @{
    timestamp = $timestamp
    device = $hostname
    user = $user
    platform = "Windows"
    status = $overallStatus
    components = @{
        mounts = @{
            flux = $fluxMounted
            space = $spaceMounted
            time = $timeMounted
        }
    }
} | ConvertTo-Json -Depth 3

if ($spaceMounted) {
    if (-not (Test-Path $statusDir)) {
        New-Item -Path $statusDir -ItemType Directory -Force | Out-Null
    }
    $jsonPayload | Out-File -FilePath $statusFile -Encoding utf8
    Write-Host "Health status written to ${statusFile}"
} else {
    Write-Host "ERROR: Cannot write health status - S: drive is not mounted."
}
